import{_ as e,o as n,c as i,e as o}from"./app.61d52ebc.js";const t={},a=o('<h1 id="configuration-validation" tabindex="-1" data-s="27547"><a class="header-anchor" href="#configuration-validation" aria-hidden="true">#</a> Configuration validation</h1><p data-s="27548">The files in this directory define and validate the configuration that is read from a <code>wrangler.toml</code> file.</p><p data-s="27549">The configuration for a Worker is complicated since we can define different &quot;environments&quot;, and each environment can have its own configuration.<br> There is a default (&quot;top-level&quot;) environment and then named environments that provide environment specific configuration.</p><p data-s="27550">This is further complicated by the fact that there are three kinds of environment configuration:</p><ul data-s="27551"><li><strong>non-overridable</strong>: these values are defined once in the top-level configuration, apply to all environments and cannot be overridden by an environment.</li><li><strong>inheritable</strong>: these values can be defined at the top-level but can also be overridden by environment specific values.<br> Named environments do not need to provide their own values, in which case they inherit the value from the top-level.</li><li><strong>non-inheritable</strong>: these values must be explicitly defined in each environment if they are defined at the top-level.<br> Named environments do not inherit such configuration and must provide their own values.</li></ul><p data-s="27552">All configuration values in <code>wrangler.toml</code> are optional and will receive a default value if not defined.</p><h2 id="types" tabindex="-1" data-s="27553"><a class="header-anchor" href="#types" aria-hidden="true">#</a> Types</h2><h3 id="environment" tabindex="-1" data-s="27554"><a class="header-anchor" href="#environment" aria-hidden="true">#</a> Environment</h3><p data-s="27555">The fields that can be defined within the <code>env</code> containers are defined in the <a href="./environment.ts"><code>Environment</code></a> type.<br> This includes the <code>EnvironmentInheritable</code> and <code>EnvironmentNonInheritable</code> fields.</p><h3 id="config" tabindex="-1" data-s="27556"><a class="header-anchor" href="#config" aria-hidden="true">#</a> Config</h3><p data-s="27557">The &quot;non-overridable&quot; types are defined in the <a href="./config.ts"><code>ConfigFields</code></a> type.<br> The <code>Config</code> type is the overall configuration, which consists of the <code>ConfigFields</code> and also an <code>Environment</code>.<br> In this case the <code>Environment</code>, here, corresponds to the &quot;currently active&quot; environment. This is specified by the <code>--env</code> command line argument.<br> If there is no argument passed then the currently active environment is the &quot;top-level&quot; environment.<br> The fields in <code>Config</code> and <code>Environment</code> are not generally optional and so you can expect they have been filled with suitable inherited or default values.<br> These types should be used when you are working with fields that should be passed to commands.</p><h3 id="rawconfig" tabindex="-1" data-s="27558"><a class="header-anchor" href="#rawconfig" aria-hidden="true">#</a> RawConfig</h3><p data-s="27559">The <code>RawConfig</code> type is a version of <code>Config</code>, where all the fields are optional.<br> The <code>RawConfig</code> type includes <code>DeprecatedConfigFields</code> and <code>EnvironmentMap</code>.<br> It also extends the <code>RawEnvironment</code> type, which is a version of <code>Environment</code> where all the fields are optional.<br> These optional fields map to the actual fields found in the <code>wrangler.toml</code>.<br> These types should be used when you are working with raw configuration that is read or will be written to a <code>wrangler.toml</code>.</p><h2 id="validation" tabindex="-1" data-s="27560"><a class="header-anchor" href="#validation" aria-hidden="true">#</a> Validation</h2><p data-s="27561">Validation is triggered by passing a <code>RawConfig</code> object, and the active environment name, to the <code>normalizeAndValidateConfig()</code> function.<br> This function will return:</p><ul data-s="27562"><li>a <code>Config</code> object, where all the fields have suitable valid values</li><li>a <code>Diagnostics</code> object, which contains any errors or warnings from the validation process</li></ul><p data-s="27563">The field values may have been parsed directly from the <code>RawConfig</code>, inherited into a named environment from the top-level environment, or given a default value.<br> Generally, if there are any warnings they should be presented to the user via <code>logger.warn()</code> messages,<br> and if there are any errors then an <code>Error</code> should be thrown describing these errors.</p><p data-s="27564">The <code>Diagnostics</code> object is hierarchical: each <code>Diagnostics</code> instance can contain a collection of child <code>Diagnostics</code> instance.<br> When checking for or rendering warnings and errors, the <code>Diagnostics</code> class will automatically traverse down to all its children.</p><h2 id="usage" tabindex="-1" data-s="27565"><a class="header-anchor" href="#usage" aria-hidden="true">#</a> Usage</h2><p data-s="27566">The <a href="./index.ts">high level API</a> for configuration processing consists of the <code>findWranglerToml()</code> and <code>readConfig()</code> functions.</p><h3 id="readconfig" tabindex="-1" data-s="27567"><a class="header-anchor" href="#readconfig" aria-hidden="true">#</a> readConfig()</h3><p data-s="27568">The <code>readConfig()</code> function will find the nearest <code>wrangler.toml</code> file, load and parse it, then validate and normalize the values into a <code>Config</code> object.<br> Note that you should pass the current active environment name in as a parameter. The resulting <code>Config</code> object will contain only the fields appropriate to that environment.<br> If there are validation errors then it will throw a suitable error.</p><h2 id="changing-configuration" tabindex="-1" data-s="27569"><a class="header-anchor" href="#changing-configuration" aria-hidden="true">#</a> Changing configuration</h2><h3 id="add-a-new-configuration-field" tabindex="-1" data-s="27570"><a class="header-anchor" href="#add-a-new-configuration-field" aria-hidden="true">#</a> Add a new configuration field</h3><p data-s="27571">When a new field needs to be added to the <code>wrangler.toml</code> configuration you will need to add to the types and validation code in this directory.</p><p data-s="27572">Here are some steps that you should consider when doing this:</p><ul data-s="27573"><li>add the new field to one of the interface: <ul data-s="27574"><li>if the field is not overridable in an environment then add it to the <code>ConfigFields</code> interface.</li><li>if the field can be inherited and overridden in a named environment then add it to the <code>EnvironmentInheritable</code> interface.</li><li>if the field cannot be inherited and must be specified in each named environment then add it to the <code>EnvironmentNonInheritable</code> interface.</li></ul></li><li>if the field is experimental then add a call to the <code>experimental()</code> function: <ul data-s="27575"><li>if the field is now in the <code>ConfigDeprecated</code> interface then add the call to the <code>normalizeAndValidateConfig()</code> function.</li><li>if the field is now in the <code>EnvironmentDeprecated</code> interface then add the call to the <code>normalizeAndValidateEnvironment()</code> function.</li></ul></li><li>add validation and normalization to the interface <ul data-s="27576"><li>if the field is in <code>ConfigFields</code> then add validation calls to <code>normalizeAndValidateConfig()</code> and assign the normalized value to the appropriate property in the <code>config</code> object.</li><li>if the field is in <code>EnvironmentInheritable</code> then call <code>inheritable()</code> in <code>normalizeAndValidateEnvironment()</code> and assign the normalized value to the appropriate property in the <code>environment</code> object.</li><li>if the field is in <code>EnvironmentNonInheritable</code> then call <code>notInheritable()</code> in <code>normalizeAndValidateEnvironment()</code> and assign the normalized value to the appropriate property in the <code>environment</code> object.</li></ul></li><li>update the tests in <code>configuration.test.ts</code><ul data-s="27577"><li>add to the <code>&quot;should use defaults for empty configuration&quot;</code> test to prove the correct default value is assigned</li><li>if the field is in <code>ConfigFields</code> add tests to the <code>&quot;top-level non-environment configuration&quot;</code> block to check the validation and normalization of values</li><li>if the field is in <code>EnvironmentInheritable</code> or <code>EnvironmentNonInheritable</code><ul data-s="27578"><li>add tests to the <code>&quot;top-level environment configuration&quot;</code> block to check the validation and normalization of values</li><li>add tests to the <code>&quot;named environment configuration&quot;</code> block to check the inheritance of values</li></ul></li></ul></li></ul><h3 id="remove-a-configuration-field" tabindex="-1" data-s="27579"><a class="header-anchor" href="#remove-a-configuration-field" aria-hidden="true">#</a> Remove a configuration field</h3><p data-s="27580">We should not just remove a field from use, since users would not know that this field is no longer needed, nor how to migrate to any new usage.<br> Instead we should first deprecate it, and then then remove it in a future major release.</p><ul data-s="27581"><li>move the field to a deprecation interface: <ul data-s="27582"><li>if the field was originally in <code>ConfigFields</code> then move it to the <code>ConfigDeprecated</code> interface.</li><li>if the field was originally in either <code>EnvironmentInheritable</code> or <code>EnvironmentNonInheritable</code> then move it to the <code>EnvironmentDeprecatedInterface</code>.</li></ul></li><li>remove the validation for the field <ul data-s="27583"><li>the TypeScript compiler should indicate where there is now an unknown field, so that you can remove its validation and normalization from the code base.</li></ul></li><li>add a deprecation warning by calling <code>deprecated()</code><ul data-s="27584"><li>if the field is now in the <code>ConfigDeprecated</code> interface then add the call to the <code>normalizeAndValidateConfig()</code> function.</li><li>if the field is now in the <code>EnvironmentDeprecated</code> interface then add the call to the <code>normalizeAndValidateEnvironment()</code> function.</li></ul></li><li>update the tests in <code>configuration.test.ts</code><ul data-s="27585"><li>Find tests where the field is mentioned and either remove them (e.g. validation) or update to show the deprecation message.</li></ul></li></ul>',30),d=[a];function r(l,c){return n(),i("div",null,d)}const s=e(t,[["render",r],["__file","index.html.vue"]]);export{s as default};
